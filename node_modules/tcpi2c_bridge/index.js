const util = require('util');
const {spawn} = require('child_process');
const {Duplex} = require('stream');
const debug = util.debuglog('tcpi2c_bridge');
const sem = require('semaphore')(1);

class Connection extends Duplex {
    constructor(callback) {
        super({});
        debug("New connection on waitlist");
        this.nc = new Promise(resolve => sem.take(() => {
            debug("Spawning nc...");
            resolve(spawn('nc', ['myrio', 1234]));
        }));
        this.nc.then(nc => {
            nc.stdout.on('data', (chunk) => {
                debug("< %o", chunk);
                if (!this.push(chunk)) {
                    nc.stdout.pause();
                }
            });
            nc.stdout.on('end', () => this.push(null));
            nc.on('error', error => this.emit('error', error));
            nc.on('close', (code) => {
                debug("nc closed.");
                sem.leave();
                if (code) this.emit('error', new Error("nc exited with status " + code));
                this.emit('close')
            });
            nc.stderr.on('data', chunk => debug("nc: %s", chunk));
            if (callback) setImmediate(callback);
        });
        process.on('exit', () => {
            this.destroy(new Error("Process exited"));
        });
    }

    _write(chunk, encoding, callback) {
        debug("> %o (%s)", chunk, encoding);
        this.nc.then(nc => nc.stdin.write(...arguments));
    }

    _destroy(err, callback) {
        this.nc.then(nc => {
            try {
                debug("Killing nc...");
                nc.kill();
            } catch (e) {
                callback(e);
            }
            callback();
        }, callback);
    }

    _final() {
        this.nc.then(nc => {
            debug("EOF");
            nc.stdin.end(...arguments)
        });
    }

    _read(size) {
        this.nc.then(nc => nc.stdout.resume());
    }
}

module.exports = Connection;
